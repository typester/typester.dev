{"title":"Retrieve River wayland compositor state via GraphQL","date":"2025-09-27T21:47:00-07:00","tags":["linux","wayland","river","rust","graphql"],"eid":"61278308-fad3-4a8f-8fc6-39b903da0b6a","image":"https://live.staticflickr.com/65535/54816919324_fb7e775e79_b.jpg","content":"<p>At work I use GraphQL quite a lot, but in my personal projects—or outside of work—I hadn’t been using it at all.\nSo I thought: wouldn’t it be fun to make various things accessible via GraphQL?\nAs a start, I built something that exposes information from <strong>River</strong>, my favorite Wayland compositor.</p>\n<blockquote>\n<p><a href=\"https://github.com/typester/riverql\">typester/riverql: GraphQL bridge for the River Wayland compositor, plus a lightweight CLI client.</a></p>\n</blockquote>\n<h3>Examples</h3>\n<h4>List of outputs</h4>\n<pre><code class=\"shell\">&#10095; riverql <span class=\"string\">'query { outputs { name } }'</span>\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"outputs\"</span>:[{<span class=\"string\">\"name\"</span>:<span class=\"string\">\"DP-1\"</span>},{<span class=\"string\">\"name\"</span>:<span class=\"string\">\"DP-2\"</span>}]}}</code></pre>\n<h4>Tag information of DP-1</h4>\n<pre><code class=\"shell\">&#10095; riverql <span class=\"string\">'query { output(name: \"DP-1\") { viewTags, focusedTags, urgentTags } }'</span>\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"output\"</span>:{<span class=\"string\">\"focusedTags\"</span>:5,<span class=\"string\">\"urgentTags\"</span>:0,<span class=\"string\">\"viewTags\"</span>:[4,1,2,512,256]}}}</code></pre>\n<h4>Array version</h4>\n<p>River represents tag information as a bitmask, but for software that cannot easily handle bit operations there is also a <code>tagsList</code> flag.\nWhen you pass <code>tagList: true</code>, you get the data in array form instead of bitmasks:</p>\n<pre><code class=\"shell\">&#10095; riverql <span class=\"string\">'query { output(name: \"DP-1\", tagList: true) { viewTagsList, focusedTagsList, urgentTagsList } }'</span>\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"output\"</span>:{<span class=\"string\">\"focusedTagsList\"</span>:[0,2],<span class=\"string\">\"urgentTagsList\"</span>:[],<span class=\"string\">\"viewTagsList\"</span>:[2,0,1,9,8]}}}</code></pre>\n\n<p>The result is the same as above, but expressed as arrays.\nI implemented this because I needed it when integrating with eww, as I’ll describe later.</p>\n<h4>Real-time updates (subscription)</h4>\n<p>All of this information can also be retrieved in real time via GraphQL subscriptions:</p>\n<pre><code class=\"shell\">&#10095; riverql <span class=\"string\">'subscription { events: eventsForOutput(outputName: \"DP-1\", tagList: true) { type: __typename ... on OutputFocusedTags { tagsList } ... on SeatFocusedView { title }}}'</span>\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"tagsList\"</span>:[0],<span class=\"string\">\"type\"</span>:<span class=\"string\">\"OutputFocusedTags\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"title\"</span>:<span class=\"string\">\"typester@karas:~\"</span>,<span class=\"string\">\"type\"</span>:<span class=\"string\">\"SeatFocusedView\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"title\"</span>:<span class=\"string\">\"Emacs\"</span>,<span class=\"string\">\"type\"</span>:<span class=\"string\">\"SeatFocusedView\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"tagsList\"</span>:[2],<span class=\"string\">\"type\"</span>:<span class=\"string\">\"OutputFocusedTags\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"title\"</span>:<span class=\"string\">\"typester@karas:~\"</span>,<span class=\"string\">\"type\"</span>:<span class=\"string\">\"SeatFocusedView\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"tagsList\"</span>:[0],<span class=\"string\">\"type\"</span>:<span class=\"string\">\"OutputFocusedTags\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"tagsList\"</span>:[0,2],<span class=\"string\">\"type\"</span>:<span class=\"string\">\"OutputFocusedTags\"</span>}}}\n{<span class=\"string\">\"data\"</span>:{<span class=\"string\">\"events\"</span>:{<span class=\"string\">\"title\"</span>:<span class=\"string\">\"Emacs\"</span>,<span class=\"string\">\"type\"</span>:<span class=\"string\">\"SeatFocusedView\"</span>}}}\n<span class=\"function-name\">...</span>(snip)...</code></pre>\n\n<p>This was my first time using subscriptions, since I had never needed them at work.\nTo my surprise, they turned out to be very convenient. The server-side implementation wasn’t that difficult either, so if I get the chance I’d like to use subscriptions at work too.</p>\n<h4>Server</h4>\n<p>Running <code>riverql --server</code> launches a GraphQL server.\nBy default it listens on a Unix socket<a class=\"footref\" href=\"#fn1\" id=\"r1\">[1]</a>, but if you use something like <code>--listen tcp://127.0.0.1:8080</code>, it works as a regular HTTP server.\nGraphQL is then available at <code>(http|ws)://127.0.0.1:8080/graphql</code>, and you can open <code>http://127.0.0.1:8080/graphiql</code> in your browser to play around with queries in a GraphQL IDE.</p>\n<h3>Building a status bar with Eww</h3>\n<p><a href=\"https://github.com/elkowar/eww\">Eww</a> is one of my favorite pieces of software.\nIt lets you build GTK widgets using a Lisp-like DSL called yuck. The layout model is a little quirky, but if you’re comfortable with React you’ll probably feel at home writing UI in yuck<a class=\"footref\" href=\"#fn2\" id=\"r2\">[2]</a>.\nYou can even build status bars with it. Among the many bar implementations out there, I think Eww is one of the most flexible.</p>\n<p>Here’s what I came up with:</p>\n<section class=\"image\">\n  <div>\n    <a data-flickr-embed=\"true\" href=\"https://www.flickr.com/photos/typester/54816919324/in/datetaken-public/\" title=\"Eww status-bar with RiverQL\"><img src=\"https://live.staticflickr.com/65535/54816919324_fb7e775e79_b.jpg\" width=\"1024\" height=\"683\" alt=\"Eww status-bar with RiverQL\"/></a><script async src=\"//embedr.flickr.com/assets/client-code.js\" charset=\"utf-8\"></script>\n  </div>\n</section>\n\n<p>There are two ways to connect Eww with riverql:</p>\n<h4>1. Polling with <code>defpoll</code></h4>\n<p>This repeatedly executes the specified command at a given interval:</p>\n<pre><code class=\"yuck\">(<span class=\"keyword\">defpoll</span> river-outputs\n         <span class=\"builtin\">:interval</span> <span class=\"string\">\"1s\"</span>\n         <span class=\"builtin\">:initial</span> <span class=\"string\">\"{}\"</span>\n         <span class=\"string\">`riverql 'query { outputs { name } }'`</span>)</code></pre>\n\n<p>Use this when you want to run GraphQL queries.</p>\n<h4>2. Real-time updates with <code>deflisten</code></h4>\n<p>This updates a variable whenever the specified command produces output:</p>\n<pre><code class=\"yuck\">(<span class=\"keyword\">deflisten</span> river-focused-view <span class=\"builtin\">:initial</span> <span class=\"string\">\"{}\"</span>\n           <span class=\"string\">\"riverql 'subscription { events { ... on SeatFocusedView { title }}}'\"</span>)</code></pre>\n\n<p>Use this when you want GraphQL subscriptions.</p>\n<p>I’ve included code in the repository’s examples, but due to yuck’s limitations, even with the <code>tagList</code> feature I still had to combine riverql with jq to build the UI I wanted<a class=\"footref\" href=\"#fn3\" id=\"r3\">[3]</a>.</p>\n<h3>Conclusion</h3>\n<p>Originally I made this just for fun, but after actually using it I found it surprisingly useful.\nPerhaps it’s because I’m already comfortable with GraphQL, but some clear advantages are:</p>\n<ul>\n<li>A unified interface to retrieve information</li>\n<li>Ability to select only the fields you need</li>\n<li>Full visibility of the API by inspecting the schema</li>\n</ul>\n\n<p>Wouldn’t it be interesting if not just River, but all sorts of things could be accessed via GraphQL?\nMaybe I’ll start by making a <strong>SysQL</strong> for system information.</p>\n<aside class=\"footdef\">\n<p id=\"fn1\"><a href=\"#r1\">[1]</a> Intended usage is to run <code>riverql --server &amp;</code> in your river init script.</p>\n<p id=\"fn2\"><a href=\"#r2\">[2]</a> <p>Tip for React engineers: In yuck’s <code>box</code> widget (used for layout), <code>:space-evenly</code> defaults to <code>true</code>.\nIf you try to lay things out as if it were a flexbox, you’ll probably get tripped up by this!</p></p>\n<p id=\"fn3\"><a href=\"#r3\">[3]</a> One could argue that it’s better to shape riverql’s responses to match Eww’s needs, but…</p>\n</aside>\n"}
