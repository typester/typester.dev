{"title":"Mobile-app core in Rust #1: Overview","date":"2024-11-14T16:32:00-08:00","tags":["rust","rust-mobile-core"],"eid":"70df844d-3bd5-463c-b33c-5627a26f6522","image":null,"content":"<p>I recently created the core logic of several mobile apps using Rust. I found this to be an excellent architecture, so I plan to explain its details over several entries.</p>\n<p>The first entry will summarize an overview and the concept of this architecture.</p>\n\n<h3>Why am I doing this?</h3>\n<p>If you're a Rust enthusiast, you'll understand: programming in Rust gives a great sense of reassurance. Compared to other programming languages, there are many situations where you can be confident there are no bugs.</p>\n<p>Because programming in Rust is so comfortable, the longer you use it, the more you want to write as much code as possible in Rust. I’m no exception, and that’s the initial reason I started trying out this architecture.</p>\n<p>What began as mere curiosity turned out to be a much better architecture than I expected. I want more people to try it, which is why I’m starting this blog entry series.</p>\n\n<h3>Overview of the Architecture</h3>\n<p>In this architecture, the core functionality of the app is implemented entirely in Rust, while the UI parts are implemented natively.</p>\n<p>For bridging Rust code with Kotlin/Swift, I use a crate called <a href=\"https://github.com/mozilla/uniffi-rs\">UniFFI</a>.</p>\n<p>Below is a diagram quoted from the UniFFI site:</p>\n<section class=\"image\">\n  <div>\n    <img src=\"/images/uniffi_diagram.png\" />\n    <p>UniFFI diagram</p>\n  </div>\n</section>\n\n<p>The portion enclosed by the black solid line in the middle of the diagram is automatically generated by UniFFI. This means we only need to write the logic part in Rust (the lower part of the diagram) and the UI part (the upper part).</p>\n<p>Let’s look at a sample UI implementation using Swift UI.</p>\n<pre><code class=\"swift\"><span class=\"swift-modeXkeyword\">import</span> SwiftUI\n\n<span class=\"swift-modeXkeyword\">struct</span> <span class=\"swift-modeXfunction-name\">TokenListScreen</span>: View {\n    <span class=\"keyword\">@State</span> <span class=\"swift-modeXkeyword\">private</span> <span class=\"swift-modeXkeyword\">var</span> tokens: [Token] = []\n\n    <span class=\"swift-modeXkeyword\">var</span> body: <span class=\"swift-modeXkeyword\">some</span> View {\n        NavigationStack {\n            <span class=\"swift-modeXfunction-call\">List</span>(tokens, id: \\.<span class=\"swift-modeXproperty-access\">id</span>) { token <span class=\"swift-modeXkeyword\">in</span>\n                NavigationLink {\n                    <span class=\"swift-modeXfunction-call\">TokenDetailScreen</span>(id: token.<span class=\"swift-modeXproperty-access\">id</span>)\n                } label: {\n                    <span class=\"swift-modeXfunction-call\">Text</span>(token.<span class=\"swift-modeXproperty-access\">account</span>)\n                }\n            }\n            .<span class=\"swift-modeXfunction-call\">navigationTitle</span>(<span class=\"string\">\"Auth2\"</span>)\n            .<span class=\"swift-modeXbuiltin-property\">task</span> {\n                <span class=\"swift-modeXkeyword\">await</span> <span class=\"swift-modeXfunction-call\">load</span>()\n            }\n        }\n    }\n\n    <span class=\"swift-modeXkeyword\">private</span> <span class=\"swift-modeXkeyword\">func</span> <span class=\"swift-modeXfunction-name\">load</span>() <span class=\"swift-modeXkeyword\">async</span> {\n        <span class=\"swift-modeXkeyword\">do</span> {\n            tokens = <span class=\"swift-modeXkeyword\">try</span> <span class=\"swift-modeXkeyword\">await</span> Auth2Bridge.<span class=\"swift-modeXbuiltin-method\">shared</span>().<span class=\"swift-modeXfunction-call\">listTokens</span>()\n        } <span class=\"swift-modeXkeyword\">catch</span> {\n            <span class=\"swift-modeXbuiltin-function\">print</span>(<span class=\"string\">\"failed to load tokens: \\(</span>error<span class=\"string\">)\"</span>)\n        }\n    }\n}</code></pre>\n\n<p>Here, <code>Auth2Bridge</code> is a struct implemented in Rust and exposed as a Swift class by UniFFI. The corresponding Rust code looks like this:</p>\n<pre><code class=\"rust\"><span class=\"preprocessor\">#[derive(uniffi::Object)]</span>\n<span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"type\">Auth2Bridge</span> {\n    <span class=\"variable-name\">inner</span>: <span class=\"type\">Arc</span>&lt;<span class=\"type\">Auth2</span>&gt;,\n}\n\n<span class=\"preprocessor\">#[uniffi::export]</span>\n<span class=\"keyword\">impl</span> <span class=\"type\">Auth2Bridge</span> {\n    <span class=\"comment-delimiter\">// </span><span class=\"comment\">snip...</span>\n    <span class=\"keyword\">pub</span> <span class=\"keyword\">async</span> <span class=\"keyword\">fn</span> <span class=\"function-name\">list_tokens</span>(<span class=\"rust-ampersand\">&amp;</span><span class=\"keyword\">self</span>) -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Vec</span>&lt;<span class=\"type\">Token</span>&gt;, <span class=\"type\">Error</span>&gt; {\n        <span class=\"keyword\">let</span> <span class=\"variable-name\">inner</span> = <span class=\"keyword\">self</span>.inner.clone();\n        rt().spawn(<span class=\"keyword\">async</span> <span class=\"keyword\">move</span> { inner.list_tokens().<span class=\"keyword\">await</span> }).<span class=\"keyword\">await</span><span class=\"rust-question-mark\">?</span>\n    }\n    <span class=\"comment-delimiter\">// </span><span class=\"comment\">...snip</span>\n}</code></pre>\n\n<p>This <code>Auth2Bridge</code> is essentially just a wrapper around <code>Auth2</code>. I won’t explain the reasoning here, it might be covered in following entries.</p>\n<p>The <code>list_tokens</code> method of <code>Auth2</code> is as follows. This is the actual implementation of <code>list_tokens</code>:</p>\n<pre><code class=\"rust\"><span class=\"keyword\">pub</span> <span class=\"keyword\">async</span> <span class=\"keyword\">fn</span> <span class=\"function-name\">list_tokens</span>(<span class=\"rust-ampersand\">&amp;</span><span class=\"keyword\">self</span>) -&gt; <span class=\"type\">Result</span>&lt;<span class=\"type\">Vec</span>&lt;<span class=\"type\">Token</span>&gt;, <span class=\"type\">Error</span>&gt; {\n    <span class=\"type\">Ok</span>(<span class=\"keyword\">self</span>\n        .db\n        .list_tokens()\n        .<span class=\"keyword\">await</span><span class=\"rust-question-mark\">?</span>\n        .into_iter()\n        .map(<span class=\"type\">Token</span>::from)\n        .collect())\n}</code></pre>\n\n<p>It’s a simple function that fetches tokens from the database and returns them.</p>\n<p>If you look back at the Swift code, you’ll notice that the async function in Rust is treated as an async function in Swift as well. By using UniFFI, you can expose Rust functionality to Kotlin/Swift without having to worry much about the language differences.</p>\n<p>Additionally, the return value <code>Vec&lt;Token&gt;</code> is similarly transformed into a Swift version by UniFFI, allowing it to be used naturally in Swift code as shown below:</p>\n<pre><code class=\"swift\"><span class=\"swift-modeXfunction-call\">List</span>(tokens, id: \\.<span class=\"swift-modeXproperty-access\">id</span>) { token <span class=\"swift-modeXkeyword\">in</span>\n    NavigationLink {\n        <span class=\"swift-modeXfunction-call\">TokenDetailScreen</span>(id: token.<span class=\"swift-modeXproperty-access\">id</span>)\n    } label: {\n        <span class=\"swift-modeXfunction-call\">Text</span>(token.<span class=\"swift-modeXproperty-access\">account</span>)\n    }\n}</code></pre>\n\n<p>Pretty neat, right?</p>\n<p>Similarly, UniFFI generates glue code for Kotlin, making it feel as if the Rust code is a native part of Kotlin.</p>\n<p>There are many solutions for writing cross-platform mobile apps, but given how convenient this approach is, I think Rust is definitely a viable option.</p>\n\n<h3>The Role of Jetpack Compose / Swift UI</h3>\n<p>Another important factor is the emergence of new UI libraries like <a href=\"https://developer.android.com/compose\">Jetpack Compose</a> and <a href=\"https://developer.apple.com/xcode/swiftui/\">Swift UI</a>.</p>\n<p>These libraries make creating UIs very simple. Writing UIs natively with these libraries while sharing core functionality implemented in Rust seems like an ideal architecture.</p>\n<p>Those with experience in React will find their experience helpful in learning Compose or Swift UI. These libraries have concepts and patterns that feel familiar to React developers, making it easier to pick them up quickly. I had about five years of React Native experience, and I quickly became comfortable creating UIs with these.</p>\n<p>Here’s a sample app. It took me about a day to implement the Rust library and Android app, and only 2-3 hours to build the iOS version using the same library.</p>\n\n<h3>Sample Application</h3>\n<p>I’ve published a simple sample app created with this architecture. All the code introduced in this article is from this app.</p>\n<p><a href=\"https://github.com/typester/auth2\">https://github.com/typester/auth2</a></p>\n<p>Though simple, it includes features useful for real-world apps, such as:</p>\n<ul>\n<li>Integration with a database (SQLite)\n<ul>\n<li>Database migration</li>\n</ul></li>\n<li>Integration with KeyStore or Keychain</li>\n<li>Output of tracing logs as app logs</li>\n</ul>\n\n<p>I plan to explain these features in more detail in future entries.</p>\n\n<h3>How does it compare to React Native?</h3>\n<p>I have about five years of experience with React Native, but after discovering this architecture, I can’t imagine going back to it.</p>\n<p>The biggest reason, as you might expect, is that I want to write in Rust!🤣 But there are also legitimate reasons beyond that:</p>\n<ul>\n<li>Performance</li>\n<li>Ease of implementation</li>\n<li>Ease of adopting the latest features on iOS and Android</li>\n</ul>\n\n<p>Regarding performance, it almost goes without saying. Compose and Swift UI are native frameworks, so they often outperform React Native, which runs on JavaScript.</p>\n<p>As for ease of implementation, if you’re developing an app for either Android or iOS alone, the cost of implementation feels nearly identical. That’s how well-designed Compose and Swift UI are. For apps targeting both platforms, you’ll need to implement the UI separately for each, which makes it costlier than React Native. However, since you can share a common library written in Rust, it’s not twice the cost. Personally, I believe the other benefits outweigh this additional effort.</p>\n<p>Another advantage of Compose and Swift UI is their ability to adopt the latest features immediately. From the moment a new OS is released, you can leverage its features. With React Native or similar frameworks, you often have to wait for them to support those new features.</p>\n\n\n<h3>Future Entries</h3>\n<p>Next up will likely be an article about setting up the development environment. I’d love to hear your thoughts or requests for topics via <a href=\"https://pdx.social/@typester\">Mastodon</a>. Thank you for reading this far!</p>\n"}
