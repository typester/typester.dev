{"title":"Introducing rust-musl-cross-docker-arch","date":"2024-12-04T09:54:00-08:00","tags":["rust","docker"],"eid":"354eca2e-1e93-441d-8dae-0f91688116c9","image":null,"content":"<p>I created a project called <a href=\"https://github.com/typester/rust-musl-cross-docker-arch\">rust-musl-cross-docker-arch</a>.</p>\n<p>This is simply a retagged version of <a href=\"https://github.com/rust-cross/rust-musl-cross\">rust-musl-cross</a> with tags in the format <code>${RUST_VERSION}-${ARCH}</code> (e.g., <code>1.83.0-arm64</code>).</p>\n\n<h3>What is rust-musl-cross?</h3>\n<p>This is a Docker image that allows you to cross-compile static Rust programs for various architectures using musl. It is very convenient when you need to cross-build.</p>\n<p>Even without cross-building, creating statically compiled applications lets you transfer only the Rust binary to a small base image, enabling you to create compact Docker images, which can improve deployment speed. Personally, I use this image to create small Docker images when deploying to low-spec edge devices or VPS environments.</p>\n<p>For example, the Dockerfile for this blog (operated on a budget VPS) looks like this:</p>\n<pre><code class=\"dockerfile\"><span class=\"keyword\">ARG</span> <span class=\"variable-name\">RUST_VERSION</span>=latest\n\n<span class=\"keyword\">FROM</span> <span class=\"dockerfile-image-name\">ghcr.io/typester/rust-musl-cross-docker-arch:$RUST_VERSION-$TARGETARCH</span> AS <span class=\"dockerfile-image-alias\">builder</span>\n\n<span class=\"keyword\">COPY</span> . .\n<span class=\"keyword\">RUN</span> cargo build --release --target ${<span class=\"variable-name\">RUST_MUSL_CROSS_TARGET</span>}\n\n<span class=\"comment-delimiter\"># </span><span class=\"comment\">Runtime</span>\n<span class=\"keyword\">FROM</span> <span class=\"dockerfile-image-name\">alpine</span>\n\n<span class=\"keyword\">WORKDIR</span> /app\n\n<span class=\"comment-delimiter\"># </span><span class=\"comment\">Timezone PST</span>\n<span class=\"keyword\">RUN</span> apk add --no-cache tzdata\n<span class=\"keyword\">ENV</span> <span class=\"variable-name\">TZ</span>=America/Los_Angeles\n\n<span class=\"comment-delimiter\"># </span><span class=\"comment\">Copy application binary from builder image</span>\n<span class=\"keyword\">COPY</span> --<span class=\"variable-name\">from</span>=builder /home/rust/src/target/*/release/blog .\n<span class=\"comment-delimiter\"># </span><span class=\"comment\">Copy static files</span>\n<span class=\"keyword\">COPY</span> ./public /app/public\n\n<span class=\"keyword\">ENV</span> <span class=\"variable-name\">RUST_LOG</span>=info\n\n<span class=\"keyword\">EXPOSE</span> 3000\n\n<span class=\"keyword\">CMD</span> [<span class=\"string\">\"/app/blog\"</span>]</code></pre>\n\n<p>This results in an image of 16.8MB. If you strip the binary (not shown here), the size can be reduced to around 15MB.</p>\n<p>Using even smaller base images like <code>scratch</code> can make the image smaller, but such images make it harder to debug issues within the container if something goes wrong. Thatâ€™s why I use <code>alpine</code>.</p>\n<p>This project was created to address the difficulty of writing Dockerfiles when using the <code>rust-musl-cross</code> tags, especially when supporting multi-architecture builds, by retagging images to better suit my needs.</p>\n<p>I created this for personal use, but anyone else who wants to use it is more than welcome. Feedback is also greatly appreciated!</p>\n\n<h3>There is also muslrust</h3>\n<p>While writing this article, I found another project called <a href=\"https://github.com/clux/muslrust\">muslrust</a>. This project also provides base images for creating small Docker images. It includes libraries like OpenSSL and libcurl, which are commonly used, making it a good choice for those who need them.</p>\n"}
